<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>实景示例</title>
  <link rel="stylesheet" href="./public/scripts/HMap/HMap.css" type="text/css">
  <link rel="stylesheet" href="./public/scripts/Bootstrap/css/bootstrap.min.css"></link>
  <link rel="stylesheet" href="./index.css">
</head>
<body>
<div class="container-fluid">
  <div class="row">
    <div class="alert alert-success alert-dismissible" role="alert">
      <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span
        aria-hidden="true">&times;</span></button>
      <strong>提示：</strong><span>解决放大镜bug，解决翻页键、方向键bug，优化逻辑，新增测量高度工具，新增测量结果事件，
      播放、暂停快捷键，缺省绑定为空格键，onPosition事件中，增加反向箭头信息，如果当前帧包含反向帧，可以通过locateByID，
      切换上下行, 图层上增加一个参数fixSize，为true时
      要素随视角变化，false时，保持大小不变。ppv增加一个参数setPref（）详见API文档。
    </span>
    </div>
    <div class="col-md-6 map-content" id="map">
      <div class="user-tool">
        <button type="button" class="btn btn-success my-button-add" onclick="addQLLayer()">叠加桥梁图层</button>
        <button type="button" class="btn btn-success my-button-add" onclick="addSDLayer()">叠加隧道图层</button>
        <button type="button" class="btn btn-success my-button-add" onclick="addQBLayer()">叠加情报板图层</button>
        <button type="button" class="btn btn-success my-button-add" onclick="addQXLayer()">叠加气象站图层</button>
        <button type="button" class="btn btn-success my-button-add" onclick="addJKLayer()">叠加监控设备图层</button>
        <button type="button" class="btn btn-success my-button-add" onclick="addJDSSLayer()">叠加机电设施图层</button>
        <!--<button type="button" class="btn btn-success my-button-addMuch-230" onclick="addMuchPoints()">叠加大量点230</button>-->
        <!--<button type="button" class="btn btn-success my-button-addMuch-1000" onclick="testMuchPoints()">叠加大量点1000</button>-->
        <button type="button" class="btn btn-info my-button-rm" onclick="removePointLayer()">移除叠加点图层</button>
      </div>
    </div>
    <div class="col-md-6 pano-content" id="ppv">
      <div class="ppv_toolbar">
        <img class="ppv_button" src="public/icon/searchCoor.png" title="查询坐标"
             onclick="activeTool(event, 'measurePoint')"/>
        <img class="ppv_button" src="public/icon/measureLength.png" title="测量长度"
             onclick="activeTool(event, 'measureLength')"/>
        <img class="ppv_button" src="public/icon/measureArea.png" title="测量面积"
             onclick="activeTool(event, 'measureArea')"/>
        <img class="ppv_button" src="public/icon/measureheigth.png" title="测量高度"
             onclick="activeTool(event, 'measureZ')"/>
        <img class="ppv_button" src="public/icon/measurejiaodu.png" title="测量角度"
             onclick="activeTool(event, 'measureAngle')"/>
        <img class="ppv_button" src="public/icon/measurepodu.png" title="测量坡度"
             onclick="activeTool(event, 'measureSlope')"/>
        <img class="ppv_button" src="public/icon/creatPoint.png" title="创建点"
             onclick="activeTool(event, 'createPoint')"/>
        <img class="ppv_button" src="public/icon/selObject.png" title="选择对象"
             onclick="activeTool(event, 'pick')"/>
        <img class="ppv_button" src="public/icon/delObject.png" title="删除选中对象"
             onclick="activeTool(event, 'remove')"/>
        <img id="btBack" class="ppv_button" src="public/icon/back.png" title="上下行"
             onclick="activeTool(event, 'switchPic')"/>
        <!--<img class="ppv_button" src="public/icon/LRS.png" title="线性参考系"></img>-->
        <div class="play-button">
          <img class="ppv_button play" onclick="play(event)" src="public/icon/play.png" title="播放"></img>
          <img class="ppv_button stop" onclick="stop(event)" src="public/icon/stop.png" title="暂停"></img>
        </div>
      </div>
    </div>
    <!-- 模态框（Modal） -->
    <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
            <h4 class="modal-title" id="myModalLabel"></h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">关闭</button>
            <button type="button" class="btn btn-primary">确定</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal -->
    </div>
  </div>
</div>
<script src="./public/scripts/jquery/jquery.min.js"></script>
<script src="./public/scripts/ResizeEnd/resizeEnd.js"></script>
<script src="./public/scripts/Bootstrap/js/bootstrap.min.js"></script>
<script src="./public/scripts/HMap/HMap.js"></script>
<script src="./public/scripts/PPV/js/ppv.min.js"></script>
<script src="./public/scripts/axios/axios.min.js"></script>
<script src="./mapConfig.js"></script>
<script src="dataFile.js"></script>
<script type="text/javascript">
  var resolutions = [], ppv, pointFeature;
  for (var i = 0; i < cor.length; i++) {
    resolutions.push(cor[i].resolution);
  }
  var Maps = new HMap.Map();

  // 当前可以返回的帧
  var backID = '';

  var btBack = document.getElementById('btBack');

  // 初始化地图
  Maps.initMap('map', {
    controls: {
      addScaleLine: false,
      addLoading: false
    },
    interactions: {
      doubleClickZoom: true,
      keyboard: false
    },
    logo: {},
    view: {
      center: [115.92466595234826, 27.428038204473552],
      resolutions: resolutions,
      fullExtent: [109.72859368643232, 24.010266905347684, 121.13105988819079, 30.76693489432357],
      tileSize: 256,
      origin: [-400, 399.9999999999998],
      enableRotation: true, // 是否允许旋转
      projection: 'EPSG:4326',
      rotation: 0,
      zoom: 1, // resolution
      zoomFactor: 2 // 用于约束分变率的缩放因子（高分辨率设备需要注意）
    },
    baseLayers: [  // 不传时默认加载OSM地图。
      {
        layerName: 'vector',
        isDefault: true,
        layerType: 'TileXYZ',
        opaque: false, //图层是否不透明
        layerUrl: 'http://171.34.40.68:6080/arcgis/rest/services/jiangxi/JXMAP_2017_2/MapServer',
      }
    ]
  });

  // 当页面变化刷新地图
  $(window).resizeend({
    delay: 50
  }, function () {
    Maps.updateSize();
  });

  // 监听地图左键事件
  Maps.map.on('mouseDownEvent', function (event) {
    var coordinate = event.originEvent.coordinate;
    var feature = event.value;
    if (feature && coordinate && feature.getGeometry()) {
      var closestPoint = feature.getGeometry().getClosestPoint(coordinate);
      if (closestPoint) {
        console.log(closestPoint)
        ppv.locate(3, closestPoint[0], closestPoint[1], 0);
      }
    }
  })

  addLine();

  // 添加实景所在路线
  function addLine() {
    var line = lineData['data']['features'][1];
    line['attributes']['style'] = {
      stroke: {
        strokeWidth: 4,
        strokeColor: '#0000EE'
      }
    }
    line['attributes']['selectStyle'] = {
      stroke: {
        strokeWidth: 6,
        strokeColor: '#E52929'
      }
    }
    var feat = Maps.addPolyline(line, {
      layerName: 'line',
      zoomToExtent: true
    });

    var point = {
      attributes: {
        ID: '02',
        style: { // 自定义相关样式
          icon: {
            imageSrc: './public/icon/jiaodu.png'
          }
        }
      },
      geometry: [115.87258481455471, 26.380662006921387],
      geometryType: 'Point'
    };
    pointFeature = Maps.addPoint(point, {
      layerName: 'eyeFeat'
    });

    var ptx, pty;
    ptx = 115.87258481455471;
    pty = 26.380662006921387;
    initPano(ptx, pty)
  }

  // 响应位置变化事件
  function onPosition(event) {
    var lon = event.lon;
    var lat = event.lat;
    var xx = 0;
    if (event.back) {
      backID = event.back
      console.log(backID)
      btBack.style.visibility = 'visible'
    } else {
      backID = ''
      btBack.style.visibility = 'hidden'
    }
    ppv.needsUpdate = true
    Maps.setPointGeometry(pointFeature, [lon, lat])
    Maps.movePointToView([lon, lat])
  }

  // 响应角度变化事件
  function onEye(event) {
    var heading = event.heading;
    var fovx = event.fovx;
    console.log(heading);
    var style = pointFeature.getStyle()
    var cloneStyle = style.clone()
    cloneStyle.getImage().setRotation(heading / 180 * Math.PI)
    pointFeature.setStyle(cloneStyle);
    Maps.map.render()
  }
  // 响应创建要素(点)-- 点击工具创建的要素
  var fid = 0;
  function onFeatureCreate(event) {
    console.log(event)
    fid++;
    event.fid = fid;
    event.name = "我是" + event.geometry.type + fid;
    var icon = 'public/icon/point_' + parseInt(Math.random() * 4 + 1, 10) + '.png'
    event.icon = icon;
    var layerPointDef = {
      name: "路灯",
      type: "Point",//Point, Line, Polygon 三种类型，并非强约束
      color: 0xffffff,//RGBA or RGB
      opacity: 1.0,
      size: 20,
      offset: [0, 20],
      fontSize: 14,
      icon: icon
    };
    var layerLineDef = {
      name: "分道线",
      type: "Line",//Point, Line, Polygon 三种类型，并非强约束
      color: "rgb(255,0,255)",//RGBA or RGB
      opacity: 1,
      lineWidth: 4,
      fontSize: 15
    };
    var layerPolyDef = {
      name: "箭头",
      type: "Polygon",//Point, Line, Polygon 三种类型，并非强约束
      color: 'skyblue',//RGBA or RGB
      opacity: 0.5,
      lineWidth: 4,
      fontSize: 15
    };
    var layerPoint = ppv.addLayer(layerPointDef);
    var layerLine = ppv.addLayer(layerLineDef);
    var layerPoly = ppv.addLayer(layerPolyDef);
    var type = event.geometry.type;
    if (type == "Point") {
      ppv.addFeature(layerPoint, event);
    } else if (type == "LineString") {
      ppv.addFeature(layerLine, event);
    } else if (type == "Polygon") {
      ppv.addFeature(layerPoly, event);
    }
    creatFeatureOnMapView(event)
  }

  /**
   * 当在实景控件内部创建点时，响应事件在地图上绘出点
   * @param event
   */
  function creatFeatureOnMapView(event) {
    var _point = {
      attributes: {
        ID: event['fid'],
        style: { // 自定义相关样式
          icon: {
            imageSrc: event['icon']
          }
        },
        M: event['geometry']['coordinates'][3]
      },
      geometry: [event['geometry']['coordinates'][0], event['geometry']['coordinates'][1]],
      geometryType: 'Point'
    }
    Maps.addPoint(_point, {
      layerName: 'point'
    });
  }

  // 响应要素被移除
  function onFeatureRemove(event) {
    var fid = event.fid;
    console.log(fid)
  }

  // 要素选中时显示信息
  // 响应要素被选择
  function onFeatureSelect(event) {
    console.log(event.feature.userData)
    $('#myModalLabel').html('<span>' + event.layername + '</span>')
    $('.modal-body').html('<span>' + event.fid + '</span>')
    $('#myModal').modal('show')
  }

  /**
   * 测量结果监听事件
   * @param event
   */
  function onMeasure (event) {
    window.setTimeout(function () {
      console.log(event)
      var res = ''
      if (event) {
        for (var key in event) {
          res += key + ': ' + event[key] + '米' + '\n'
        }
      }
      window.alert(res)
    }, 300)
  }

  // 监听工具切换事件,功能改变时，触发事件
  function onTool (event) {
    // 24和25为播放暂停事件
    if ((event.tool !== 24) && (event.tool !== 25)) {
      ppv.stop()
    }
  }

  // 监听根据鼠标定位事件
  function onLocate (event) {
    if (event.state === 0) {
      console.log('成功')
    } else if (event.state === 1) {
      console.log('类型错误')
    } else if (event.state === 2) {
      console.log('数据错误')
    } else if (event.state === 3) {
      console.log('图片错误')
    } else if (event.state === 4) {
      console.log('服务忙')
    }
  }

  // 初始化实景控件
  function initPano(ptx, pty) {
    ppv = new PPV("ppv");
    // 设置服务地址
//    ppv.setServer("http://192.168.0.226:8013//PPVServer.asmx");
    ppv.setServer("http://211.101.37.253:8013//PPVServer.asmx");
    // 根据坐标定位实景位置
    ppv.locate(3, ptx, pty, 0);
    // 监听定位事件
    ppv.onLocate = onLocate;
    // 响应位置变化事件
    ppv.onPosition = onPosition;
    // 响应视角变化
    ppv.onEye = onEye;
    // 响应要素被创建事件
    ppv.onFeatureCreate = onFeatureCreate;
    // 响应要素被移除事件
    ppv.onFeatureRemove = onFeatureRemove;
    // 响应要素被选中事件
    ppv.onFeatureSelect = onFeatureSelect;
    // 测量结果监听事件
    ppv.onMeasure = onMeasure;
    // 监听工具切换事件,功能改变时，触发事件
    ppv.onTool = onTool;

    // 设置背景，可视范围，放大镜等工具参数
    ppv.setPref({
      bgcolor: 'rgb(255,255,255)',//'rgb(255,255,255)',
      fullView: true, // 照片是否填满div，不管是否会被裁剪
      enableArrow: true,
      enableHistory: true,
      scope: 100, // 可视范围
      magnifier:{
        size: 256,
        zoom: 5.0,
        fix: false // 是否启动放大镜后，固定位置不变。另一个方式是，放大镜随鼠标移动
      }
    })
  }

  /**
   * 控制导向箭头显示影藏
   * @param flag
   */
  function showControl (flag) {
    ppv.setPref({
      bgcolor: 'rgb(255,255,255)',//'rgb(255,255,255)',
      fullView: true, // 照片是否填满div，不管是否会被裁剪
      enableArrow: flag,
      enableHistory: true,
      scope: 100, // 可视范围
      magnifier:{
        size: 256,
        zoom: 5.0,
        fix: false // 是否启动放大镜后，固定位置不变。另一个方式是，放大镜随鼠标移动
      }
    })
  }
  // 实景工具类
  function activeTool(event, type) {
    // 页面上的按钮，如果在ppv上叠加，鼠标事件要阻止冒泡否则会造成穿透点击到窗口，影响插件事件
    event.stopPropagation();
    showControl (false)
    switch (type) {
      case 'measurePoint':
        ppv.setTool(Tool.measurePoint, true);
        break;
      case 'measureLength':
        ppv.setTool(Tool.measureLength, true);
        break;
      case 'measureArea':
        ppv.setTool(Tool.measureArea, true);
        break;
      case 'measureZ':
        ppv.setTool(Tool.measureZ, true);
        break;
      case 'measureFacade':
        ppv.setTool(Tool.measureFacade, true);
        break;
      case 'measureAngle':
        ppv.setTool(Tool.measureAngle, true);
        break;
      case 'measureSlope':
        ppv.setTool(Tool.measureSlope, true);
        break;
      case 'createPoint':
        ppv.setTool(Tool.createPoint, true);
        break;
      case 'createPolyline':
        ppv.setTool(Tool.createPolyline, true);
        break;
      case 'createPolygon':
        ppv.setTool(Tool.createPolygon, true);
        break;
      case 'pick':
        ppv.setTool(Tool.pick, true);
        break;
      case 'remove': // 创建叠加的要素不能通过ppv.setTool(Tool.remove, true)方法移除
        ppv.setTool(Tool.remove, true);
        removePointLayer()
        showControl (true)
        break;
      case 'switchPic':
        ppv.locateByID(3, backID);
        break
    }
  }
  // 播放
  function play() {
    ppv.play()
    $('.play').css('display', 'none')
    $('.stop').css('display', 'block')
  }
  // 暂停
  function stop() {
    ppv.stop()
    $('.play').css('display', 'block')
    $('.stop').css('display', 'none')
  }
  // 外部叠加点要素
  function addPointLayer() {
    var pointFeat = liveList['data']['features']
    var icon = 'public/icon/point_' + parseInt(Math.random() * 4 + 1, 10) + '.png'
    var _layerPointDef = {
      name: "桥梁",
      type: "Point",//Point, Line, Polygon 三种类型，并非强约束
      color: 0xffffff,//RGBA or RGB
      opacity: 1.0,
      size: 20,
      offset: [0, 20],
      fontSize: 14,
      icon: icon
    };
    var _layerPoint = ppv.addLayer(_layerPointDef);
    pointFeat.forEach(function (item) {
      item['attributes'].style = { // 自定义相关样式
        icon: {
          imageSrc: 'public/icon/point_1.png'
        }
      }
      var __item = {
        fid: item['attributes']['QLDM'],
        geometry: {
          coordinates: [item['geometry'][0], item['geometry'][1], 200.5938781674623],
          type: "Point"
        },
        icon: icon,
        name: item['attributes']['QLMC'],
        toGround: 0,
        type: "Feature"
      }
      Maps.addPoint(item, {
        layerName: 'pointFeat'
      });
      ppv.addFeature(_layerPoint, __item);
    })
  }
  // 移除叠加要素
  function removePointLayer() {
    // 通过layerNames移除地图上要素
    Maps.removeFeatureByLayerNames(['pointFeat', 'point', 'GIS_QL', 'GIS_SD', 'GIS_QBB', 'GIS_QXZ', 'GIS_JKSB', 'GIS_JDSS'])
    // 移除实景叠加要素
    ppv.removeAllLayers();
  }
  // 叠加大量点
  function addMuchPoints () {
    axios.get('http://211.101.37.253:8081/geoserver-sde/rest/action/search', {
      params: {
        params: JSON.stringify({
          layerName: 'GL_QIAO',
          isReturnGeometry: true
        })
      }
    })
      .then(function (response) {
        var pointFeat = response['data']['data']['features']
        var icon = 'public/icon/point_' + parseInt(Math.random() * 4 + 1, 10) + '.png'
        var _layerPointDef = {
          name: "桥梁",
          type: "Point",//Point, Line, Polygon 三种类型，并非强约束
          color: 0xffffff,//RGBA or RGB
          opacity: 1.0,
          size: 20,
          offset: [0, 20],
          fontSize: 14,
          icon: icon
        };
        var _layerPoint = ppv.addLayer(_layerPointDef);
        pointFeat.forEach(function (item) {
          item['attributes'].style = { // 自定义相关样式
            icon: {
              imageSrc: 'public/icon/point_1.png'
            }
          }
          var geo = item.geometry.split(' ')
          var geoX = geo[1].slice(1, geo[1].length)
          var geoY = geo[2].slice(0, geo[2].length - 1)
          var __item = {
            fid: item['attributes']['QLDM'],
            geometry: {
              coordinates: [geoX, geoY, 200.5938781674623],
              type: "Point"
            },
            icon: icon,
            name: item['attributes']['QLMC'],
            toGround: 0,
            type: "Feature"
          }
          Maps.addPoint(item, {
            layerName: 'pointFeat'
          });
          ppv.addFeature(_layerPoint, __item);
        })
      })
      .catch(function (error) {
        console.log(error);
      });
  }
  // 叠加一千条数据
  function testMuchPoints () {
    axios.get('./public/json/GIS_QL.json').then(function (response) {
        var pointFeat = response['data']['data']['features']
        var icon = 'public/icon/point_' + parseInt(Math.random() * 4 + 1, 10) + '.png'
        var _layerPointDef = {
          name: "桥梁",
          type: "Point",//Point, Line, Polygon 三种类型，并非强约束
          color: 0xffffff,//RGBA or RGB
          opacity: 1.0,
          size: 20,
          offset: [0, 20],
          fontSize: 14,
          icon: icon
        };
        var _layerPoint = ppv.addLayer(_layerPointDef);
        pointFeat.forEach(function (item) {
          item['attributes'].style = { // 自定义相关样式
            icon: {
              imageSrc: 'public/icon/point_1.png'
            }
          }
          var geo = item.geometry.split(' ')
          var geoX = geo[1].slice(1, geo[1].length)
          var geoY = geo[2].slice(0, geo[2].length - 1)
          var __item = {
            fid: item['attributes']['QLDM'],
            geometry: {
              coordinates: [geoX, geoY, 200.5938781674623],
              type: "Point"
            },
            icon: icon,
            name: item['attributes']['QLMC'],
            toGround: 0,
            type: "Feature"
          }
//          ppv.addFeature(_layerPoint, __item);
        })
        Maps.addPoints(pointFeat, {
          layerName: 'pointFeat'
        });
      })
      .catch(function (error) {
        console.log(error);
      });
  }

  // 叠加桥梁数据
  function addQLLayer() {
    axios.get('http://211.101.37.253:8081/geoserver-sde/rest/action/search', {
      params: {
        params: JSON.stringify({
          layerName: 'GL_QIAO',
          filter: 'SXXFX=1',
          isReturnGeometry: true
        })
      }
    }).then(function (response) {
        var pointFeat = response['data']['data']['features']
        var icon = 'public/icon/marker/icon_map_ql.png'
        var _layerPointDef = {
          name: "桥梁",
          type: "Point",//Point, Line, Polygon 三种类型，并非强约束
          color: 0xffffff,//RGBA or RGB
          opacity: 1.0,
          size: 20,
          fixSize: true,
          offset: [0, 20],
          fontSize: 14,
          icon: icon
        };
        var _layerPoint = ppv.addLayer(_layerPointDef);
        pointFeat.forEach(function (item) {
          item['attributes'].style = { // 自定义相关样式
            icon: {
              imageSrc: 'public/icon/marker/icon_map_ql.png'
            }
          }
          var geo = item.geometry.split(' ')
          var geoX = geo[1].slice(1, geo[1].length)
          var geoY = geo[2].slice(0, geo[2].length - 1)
          var __item = {
            fid: item['attributes']['QLDM'],
            geometry: {
              coordinates: [geoX, geoY, 200.5938781674623],
              type: "Point"
            },
            properties: {
              name: "test"
            },
            icon: icon,
            name: item['attributes']['QLMC'],
            toGround: 0,
            type: "Feature"
          }
          ppv.addFeature(_layerPoint, __item);
        })
        Maps.addPoints(pointFeat, {
          layerName: 'GIS_QL',
          zoomToExtent: true
        });
      })
      .catch(function (error) {
        console.log(error);
      });
  }

  // 叠加隧道数据
  function addSDLayer() {
    axios.get('http://211.101.37.253:8081/geoserver-sde/rest/action/search', {
      params: {
        params: JSON.stringify({
          layerName: 'GL_SUID',
          filter: 'SXXFX=1',
          isReturnGeometry: true
        })
      }
    })
      .then(function (response) {
        var pointFeat = response['data']['data']['features']
        var icon = 'public/icon/marker/icon_map_sd.png'
        var _layerPointDef = {
          name: "隧道",
          type: "Point",//Point, Line, Polygon 三种类型，并非强约束
          color: 0xffffff,//RGBA or RGB
          opacity: 1.0,
          size: 20,
          offset: [0, 20],
          fontSize: 14,
          icon: icon
        };
        var _layerPoint = ppv.addLayer(_layerPointDef);
        pointFeat.forEach(function (item) {
          item['attributes'].style = { // 自定义相关样式
            icon: {
              imageSrc: 'public/icon/marker/icon_map_sd.png'
            }
          }
          var geo = item.geometry.split(' ')
          var geoX = geo[1].slice(1, geo[1].length)
          var geoY = geo[2].slice(0, geo[2].length - 1)
          var __item = {
            fid: item['attributes']['SDDM'],
            geometry: {
              coordinates: [geoX, geoY, 200.5938781674623],
              type: "Point"
            },
            icon: icon,
            name: item['attributes']['SDMC'],
            toGround: 0,
            type: "Feature"
          }
          ppv.addFeature(_layerPoint, __item);
        })
        Maps.addPoints(pointFeat, {
          layerName: 'GIS_SD',
          zoomToExtent: true
        });
      })
      .catch(function (error) {
        console.log(error);
      });
  }

  // 叠加情报板数据
  function addQBLayer() {
    axios.get('http://211.101.37.253:8081/geoserver-sde/rest/action/search', {
      params: {
        params: JSON.stringify({
          layerName: 'GL_JDSS_QBB',
          filter: 'SXXFX=1',
          isReturnGeometry: true
        })
      }
    })
      .then(function (response) {
        var pointFeat = response['data']['data']['features']
        var icon = 'public/icon/marker/icon_map_qbb.png'
        var _layerPointDef = {
          name: "情报板",
          type: "Point",//Point, Line, Polygon 三种类型，并非强约束
          color: 0xffffff,//RGBA or RGB
          opacity: 1.0,
          size: 20,
          offset: [0, 20],
          fontSize: 14,
          icon: icon
        };
        var _layerPoint = ppv.addLayer(_layerPointDef);
        pointFeat.forEach(function (item) {
          item['attributes'].style = { // 自定义相关样式
            icon: {
              imageSrc: 'public/icon/marker/icon_map_qbb.png'
            }
          }
          var geo = item.geometry.split(' ')
          var geoX = geo[1].slice(1, geo[1].length)
          var geoY = geo[2].slice(0, geo[2].length - 1)
          var __item = {
            fid: item['attributes']['EQUIPMENT_CODE'],
            geometry: {
              coordinates: [geoX, geoY, 200.5938781674623],
              type: "Point"
            },
            icon: icon,
            name: item['attributes']['EQUIPMENT_NAME'],
            toGround: 0,
            type: "Feature"
          }

          ppv.addFeature(_layerPoint, __item);
        })
        Maps.addPoints(pointFeat, {
          layerName: 'GIS_QBB',
          zoomToExtent: true
        });
      })
      .catch(function (error) {
        console.log(error);
      });
  }

  // 叠加气象站数据
  function addQXLayer() {
    axios.get('http://211.101.37.253:8081/geoserver-sde/rest/action/search', {
      params: {
        params: JSON.stringify({
          layerName: 'GL_JDSS_QXZ',
          filter: 'SXXFX=1',
          isReturnGeometry: true
        })
      }
    })
      .then(function (response) {
        var pointFeat = response['data']['data']['features']
        var icon = 'public/icon/marker/icon_map_qxjcz.png'
        var _layerPointDef = {
          name: "气象站",
          type: "Point",//Point, Line, Polygon 三种类型，并非强约束
          color: 0xffffff,//RGBA or RGB
          opacity: 1.0,
          size: 20,
          offset: [0, 20],
          fontSize: 14,
          icon: icon
        };
        var _layerPoint = ppv.addLayer(_layerPointDef);
        pointFeat.forEach(function (item) {
          item['attributes'].style = { // 自定义相关样式
            icon: {
              imageSrc: 'public/icon/marker/icon_map_qxjcz.png'
            }
          }
          var geo = item.geometry.split(' ')
          var geoX = geo[1].slice(1, geo[1].length)
          var geoY = geo[2].slice(0, geo[2].length - 1)
          var __item = {
            fid: item['attributes']['EQUIPMENT_CODE'],
            geometry: {
              coordinates: [geoX, geoY, 200.5938781674623],
              type: "Point"
            },
            icon: icon,
            name: item['attributes']['EQUIPMENT_NAME'],
            toGround: 0,
            type: "Feature"
          }
          ppv.addFeature(_layerPoint, __item);
        })
        Maps.addPoints(pointFeat, {
          layerName: 'GIS_QXZ',
          zoomToExtent: true
        });
      })
      .catch(function (error) {
        console.log(error);
      });
  }

  // 叠加监控设备数据
  function addJKLayer() {
    axios.get('http://211.101.37.253:8081/geoserver-sde/rest/action/search', {
      params: {
        params: JSON.stringify({
          layerName: 'GL_JDSS_JKSS',
          filter: 'SXXFX=1',
          isReturnGeometry: true
        })
      }
    })
      .then(function (response) {
        var pointFeat = response['data']['data']['features']
        var icon = 'public/icon/marker/icon_map_spjkd.png'
        var _layerPointDef = {
          name: "监控设备",
          type: "Point",//Point, Line, Polygon 三种类型，并非强约束
          color: 0xffffff,//RGBA or RGB
          opacity: 1.0,
          size: 20,
          offset: [0, 20],
          fontSize: 14,
          icon: icon
        };
        var _layerPoint = ppv.addLayer(_layerPointDef);
        pointFeat.forEach(function (item) {
          item['attributes'].style = { // 自定义相关样式
            icon: {
              imageSrc: 'public/icon/marker/icon_map_spjkd.png'
            }
          }
          var geo = item.geometry.split(' ')
          var geoX = geo[1].slice(1, geo[1].length)
          var geoY = geo[2].slice(0, geo[2].length - 1)
          var __item = {
            fid: item['attributes']['EQUIPMENT_CODE'],
            geometry: {
              coordinates: [geoX, geoY, 200.5938781674623],
              type: "Point"
            },
            icon: icon,
            name: item['attributes']['EQUIPMENT_NAME'],
            toGround: 0,
            type: "Feature"
          }
          ppv.addFeature(_layerPoint, __item);
        })
        Maps.addPoints(pointFeat, {
          layerName: 'GIS_JKSB',
          zoomToExtent: true
        });
      })
      .catch(function (error) {
        console.log(error);
      });
  }

  // 叠加机电设施数据
  function addJDSSLayer() {
    axios.get('http://211.101.37.253:8081/geoserver-sde/rest/action/search', {
      params: {
        params: JSON.stringify({
          layerName: 'GL_LD_JDSS',
          filter: 'ID IS NOT NULL',
          isReturnGeometry: true
        })
      }
    })
      .then(function (response) {
        var pointFeat = response['data']['data']['features']
        var icon = 'public/icon/marker/icon_map_ddzx.png'
        var _layerPointDef = {
          name: "机电设施",
          type: "Point",//Point, Line, Polygon 三种类型，并非强约束
          color: 0xffffff,//RGBA or RGB
          opacity: 1.0,
          size: 20,
          offset: [0, 20],
          fontSize: 14,
          icon: icon
        };
        var _layerPoint = ppv.addLayer(_layerPointDef);
        pointFeat.forEach(function (item) {
          item['attributes'].style = { // 自定义相关样式
            icon: {
              imageSrc: 'public/icon/marker/icon_map_ddzx.png'
            }
          }
          var geo = item.geometry.split(' ')
          var geoX = geo[1].slice(1, geo[1].length)
          var geoY = geo[2].slice(0, geo[2].length - 1)
          var __item = {
            fid: item['attributes']['ID'],
            geometry: {
              coordinates: [geoX, geoY, 200.5938781674623],
              type: "Point"
            },
            icon: icon,
            name: item['attributes']['EQUIPMENT_NAME'],
            toGround: 0,
            type: "Feature"
          }
          ppv.addFeature(_layerPoint, __item);
        })
        Maps.addPoints(pointFeat, {
          layerName: 'GIS_JDSS',
          zoomToExtent: true
        });
      })
      .catch(function (error) {
        console.log(error);
      });
  }
</script>
</body>
</html>